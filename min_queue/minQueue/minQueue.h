#ifndef MIN_QUEUE
#define MIN_QUEUE

#include "../minStack/minStack.h"

// Класс MinQueue является репрезенетацией очереди двумя стеками с поддержкой минимумов.
// При добавлении элемента очереди, этот элемент добавляется в стек in.
// При удалении, элемент удаляется из стека out.
// В случае, если стек out пустой, переносим элементы стека in в стек out (транспозиция)
// При поиске минимума сравниваем минимумы обеих стеков и выбираем наименьший элемент.
//
// Данная структура будет иметь при амортизационном анализе сложность O(1).
// Воспользуемся методом потенциалов. Возьмем за потенциал количество элементов в стеке in.
// Возьмем удаление/добавление/чтение вершины стека как одинаковые по трудоемкости операции (пусть единица).
// Рассмотрим добавление в очередь (push): добавить в стек in стоит единицу, потенциал возрастает на 1.
// Тогда стоимость операции будет a_push = t_1 + P(n+1) - P(n) = 1 + n + 1 - n = 2 = O(1).
// Теперь рассмотрим удаление из очереди:
// Если old непустой, то удаление занимает единицу, потенциал не меняется => a_pop_1 = t_1 + P(n) - P(n) = t_1 = 1 = O(1)
// Если old пустой, то транспозиция занимает n, удаление из old - единицу, потенциал меняется на -n => a_pop_2 = t_n + t_1 + P(0) - P(n) = n + 1 - n = 1 = O(1).
// Взятие минимума является операцией доступа к двум стекам в худшем случае => a_min = t_2 = 2 = O(1).
// Из этого можно сделать вывод, что средняя производительность всех операций - O(1).
class MinQueue {
  private:
    MinStack in;
    MinStack out;
    void transpose();
  public:
    void push(int element);
    void pull();
    int min();
};

#endif
